# BIT

## 비트연산
^(XOR): 다르면 1, 같으면 0
~(NOT): 부정
0s, 1s: 모든 비트가 0인 값이거나 1인 값

## 비트 조작을 할 때 알아야할 사실과 트릭들
x ^ 0s = x
x ^ 1s = ~x
x ^ x = 0
x & 0s = 0
x & 1s = x
x & x = x
x | 0s = x
x | 1s = 1s
x | x = x

## 2의 보수와 음수
2의 보수를 표현하는 방법
1) k의 2^N에 대한 보수 = 2^N - k 를 2진수로 표현한뒤 부호비트 표시
e.g.) -2의 2^3에 대한 보수 = 8 - abs(-2) = 6 =(이진수)=> 110 =(앞자리부호비트1)=> 1110
8-3 = 5 => 101 => 1101
2) 양수로 표현된 2진수를 뒤집은 뒤 1을 더해
e.g.) 3을 2진수 == 011 뒤집은뒤 1을 더하면 101, 부호비트를 앞에붙이면 1101

## 논리 우측 시프트 vs 산술 우측 시프트
- 논리 우측 시프트(>>>): 비트를 오른쪽으로 옮기고 부호 비트를 0으로 채운다.(결과적으로 0)
- 산술 우측 시프트(>>): 비트를 오른쪽으로 옮기고 부호 비트는 바꾸지 않는다. **나누기2**와 같은 효과.(1s 였다면 결과적으로 -1)

## 기본적인 비트조작
> 1 << i 는 00010000과 같이 만든다
> ~(1 << i)는 11101111
### 비트값 확인: i번째 비트값이 뭔지 알수있다
```
num & (1 << i) != 0
```
### 비트값 채워넣기: i번째만 1로 만든다
```
num | (1 << i);
```
### 비트값 삭제하기: i번째만 0으로 만든다
```
int mask = ~(1 << i);
num & mask
```
- 최상위에서 i번째 비트까지 모두 삭제
> (1 << i) -1 == 0001000 - 1 == 0000111
```
int mask = (1 << i) -1;
num & mask
```
- i번째 비트에서 0번째 비트까지 모두 삭제
> -1은 11111111
> -1 << (i + 1) == 11111000
```
int mask = (-1 << (i + 1));
num & mask
```

### 비트값 바꾸기: 비트값을 삭제한 다음 원하는 값을 채워넣으면된다.

5.1 삽입: 두개의 32비트수 N,M과 위치 i,j가 주어졌을때 M을 N에 삽입.
e.g.) N = 100000000 M = 10011, i=2, j=6이면 100100110

100?????0
000111110 = 000011111 << 1(=i-1) 
         000100000 - 1 == (1 << j) -1
         => (1 << j) -1 << (i-1)
         => ~으로 반대로 뒤집는다
111000001 를 &한 후(clear)
M << i 을 | 한다.

```
N & (~ (((1 << j) -1) << (i-1))) | (M << i)
```

5.2 소수점을 이진수로, 길이가 32이하인 문자열로 표현할수 없다면 ERROR
0.5 = 1/(2^1) => 0.1 
0.25 = 1/(2^2) => 0.01
0.125 = 1/(2^3) => 0.001 ...
```java
public parse(double x){
    String rst = "0.";
    int i = 1;
    while(i < 32){
        if(x > (1/2^i)){
            x -= (1/2^i);
            rst+= "1";
        }else{
            rst+= "0"
        }
        i++;
    }
    return x == 0? rst: "ERROR";
}
```

5.3 0을 1로 바꿨을때 1이 연속으로 나올수 있는 가장 긴 길이 구하기
e.g.) 11011101111 -> 8
0의 위치를 구해서 하나씩 바꾼뒤 shift를 잘~하면 갯수를 셀수있을것같다.
```java
int N;
public void getLength(int inpt){
    N = inpt;
    //find position of 0
    ArrayList<Integer> p = new ArrayList<>();
    int idx = 0;
    int num = N;
    while(num > 0){
        if(num %2 == 0){
            p.add(idx);
        }
        num /= 2;
        idx++;
    }

    int max = 0;
    for(int i = 0; i < p.size(); i++){
        //1. 0을 1로 update
        update0To1(p.get(i))
        //2. 최초 1이 나올때까지 땡기기
        num = N;
        while(num %2 != 0){
            num/=2;
        }
        //3. 갯수세기
        int cnt = 0;
        while(num %2 != 0){
            cnt++;
            num/=2;
        }
        max = Math.max(max, cnt);
    }
    return max;
}

void update0To1(int idx){
    return N | (1 << idx)
}
```

5.4 정수를 이진수로 표기했을 때 1비트의 개수가 같은 숫자중에서 가장 작은 수와 큰수
10010이라고 치면 가장큰수는 11000, 작은수는 00011.
1의 위치를 구하면 전체 자리수가 나오니까..
가장큰수는 -1 << (전체자리수 - 1의 갯수)
가장작은수는 -1 >> (전체자리수 - 1의 갯수)
```java
public void getNums() {
	int idx = 0;
	int cnt = 0;
	// N = 18; // 10010
	int num = N;
	while (num > 0) {
		if (num % 2 == 1) {
			cnt++;
		}
		num /= 2;
		idx++;
	}

	int base = N & (-1 << (idx - cnt)); //10000
	int add = 0;
	for (int i = 0; i < cnt - 1; i++) {
		add += ~(-1 << (idx - 2 - i)) + 1; //1000
	}
	int max = base + add;
	System.out.println(max);
	
	int mb = -1 << (idx - cnt - 1); // 11100
	int min = -1 ^ mb; // 11
	System.out.println(min);
}
```

5.5 디버거: 아래 코드가 하는 일을 설명하라
> ((n & (n-1)) == 0)
짝수인지 체크..?

5.6 정수 A, B 가 있을때 A -> B가 되기위해 바꿔야 하는 비트 수?
```java
public int cntToParse(int A, int B) {
    int num = A^B;
    int cnt = 0;
    while (num > 0) {
        if (num % 2 == 1) {
            cnt++;
        }
        num /= 2;
    }
    return cnt;
}
```

5.7 스터디때 풀기

5.8
